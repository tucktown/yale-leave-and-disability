# -*- coding: utf-8 -*-
"""LeaveAndDisabilityPay_v1_2025-02-04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ofDMepzCyfR7-rHB4Yrs74kD_tXNMDNk
"""

import pandas as pd
from google.colab import files
from IPython.display import display
import re

def upload_and_read_file():
    print("Please upload a .csv or .xlsx file:")
    uploaded = files.upload()

    for file_name in uploaded.keys():
        if file_name.endswith('.csv'):
            data = pd.read_csv(file_name)
        elif file_name.endswith('.xlsx'):
            data = pd.read_excel(file_name)
        else:
            raise ValueError("Unsupported file type. Please upload a CSV or XLSX file.")

        print(f"\nPreview of {file_name}:")
        display(data.head(100))
        return data

def calculate_base_fields(data):
    """Calculate all intermediate fields needed for scenario logic"""

    # Base wage calculations
    data['WEEKLY_WAGE'] = data['PAY_RATE'] * data['SCHED_HRS']
    data['MIN_WAGE_40'] = data['MIN_WAGE'] * 40
    data['95_CT_MIN_40'] = data['MIN_WAGE_40'] * 0.95
    data['CTPL_CALC_STAR'] = (data['WEEKLY_WAGE'] - data['MIN_WAGE_40']) * 0.6
    data['CTPL_CALC'] = data['95_CT_MIN_40'] + data['CTPL_CALC_STAR']

    # CTPL payment calculations
    data['CTPL_PAYMENT_EST'] = data.apply(
        lambda x: min(x['CTPL_CALC'], x['MAX_CTPL_PAY']), axis=1
    )

    data['CTPL_PAYMENT'] = data.apply(
        lambda x: x['CTPL_PAYMENT_EST'] if pd.isna(x['CTPL_APPROVED_AMOUNT'])
        else x['CTPL_APPROVED_AMOUNT'], axis=1
    )

    # STD calculations
    data['STD_OR_NOT'] = data.apply(
      lambda x: 0 if pd.isna(x['STD_APPROVED_THROUGH']) or x['END_DATE'] > x['STD_APPROVED_THROUGH']
      else max((x['WEEKLY_WAGE'] * 0.6) - x['CTPL_PAYMENT'], 0)
        if (x['WEEKLY_WAGE'] * 0.6) > x['CTPL_PAYMENT']
        else 0, axis=1
    )

    # PTO Reserve calculations - must come before PTO_USABLE
    data['PTO_RESERVE'] = data.apply(
        lambda x: x['SCHED_HRS'] * 2 if x['EE_SUPP_PTO'] == 'N'
        else x['SCHED_HRS'] * x['EE_PTO_RTW'], axis=1
    )

    # PTO calculations - after PTO_RESERVE
    data['PTO_USABLE'] = data.apply(
      lambda x: max(x['PTO_AVAIL'] - x['PTO_RESERVE'], 0), axis=1
    )

    data['PTO_SUPP_DOLLARS'] = data['WEEKLY_WAGE'] - data['CTPL_PAYMENT'] - data['STD_OR_NOT']
    data['PTO_SUPP_HRS'] = data['PTO_SUPP_DOLLARS'] / data['PAY_RATE']

    data['PTO_USE_HRS'] = data.apply(
      lambda x: x['PTO_SUPP_HRS']
      if ((x['PTO_USABLE'] - x['PTO_SUPP_HRS']) > 0) and
        (x['PTO_SUPP_HRS'] > 0)
      else 0, axis=1
    )

    return data

def apply_logic(data):
    # Initialize PTO_AVAIL and calculated columns
    data['PTO_AVAIL'] = 160
    calculated_columns = [
        'c_STD_HOURS', 'c_DIS_SUPP', 'c_PTO_HRS', 'c_LOA_NO_HRS_PAID',
        'c_BASIC_SICK_HRS', 'c_BRIDGEPORT_SICK_HRS', 'c_LM_SICK_HRS',
        'c_LM_PTO_HRS', 'c_ATO_HRS', 'c_EXEMPT_HRS', 'c_CHECK_KRONOS'
    ]
    for col in calculated_columns:
        data[col] = None

    # Initialize scenario tracking
    data['EE_SUPP_PTO'] = 'N'
    data['EE_PTO_BANK'] = None
    data['Scenario'] = ''

    # Set year-dependent values
    data['MAX_CTPL_PAY'] = data['END_DATE'].apply(lambda x: 941.40 if x.year == 2024 else 981.91)
    data['MIN_WAGE'] = data['END_DATE'].apply(lambda x: 15.69 if x.year == 2024 else 16.35)

    # Process PTO information from NOTES
    pto_supp_regex = r'wants to supplement with PTO'
    pto_bank_regex = r'wants to keep (\d+) weeks for RTW'
    data.loc[data['NOTES'].str.contains(pto_supp_regex, na=False, case=False), 'EE_SUPP_PTO'] = 'Y'
    data['EE_PTO_RTW'] = 2
    for index, row in data.iterrows():
        match = re.search(pto_bank_regex, str(row['NOTES']), re.IGNORECASE)
        if match:
            data.at[index, 'EE_PTO_RTW'] = int(match.group(1))
    data['EE_PTO_BANK'] = data['EE_PTO_RTW'] * data['SCHED_HRS']

    # Calculate all intermediate fields
    data = calculate_base_fields(data)

    # Logic: Per Diem Employee
    per_diem_conditions = data['SCHED_HRS'] < 1
    data.loc[per_diem_conditions, 'Scenario'] = 'Per Diem Employee'
    for col in [c for c in calculated_columns if c != 'c_CHECK_KRONOS']:
      data.loc[per_diem_conditions, col] = 0
    data.loc[per_diem_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # Skip further processing for rows that matched Per Diem Employee logic
    unmatched_rows = data['Scenario'] == ''

    # Logic: Returned to Work During Last Pay Period
    rtwp_conditions = (
        (data['RTW_FT'] <= data['START_DATE']) &
        (data['EMP_STATUS'].isin(['A1', 'A2', 'A3', 'A4'])) &
        unmatched_rows
    )
    data.loc[rtwp_conditions, 'Scenario'] = 'Returned to Work During Last Pay Period'

    # Logic: Begin Date is After Current Pay Period
    begin_date_conditions = (data['BEGIN_DATE'] >= data['END_DATE']) & unmatched_rows
    data.loc[begin_date_conditions, 'Scenario'] = 'Begin Date is After Current Pay Period'
    data.loc[begin_date_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - REASON_CODE = WORKERS COMPENSATION
    pl_500_workers_comp_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'WORKERS COMPENSATION') &
        unmatched_rows
    )
    data.loc[pl_500_workers_comp_conditions, 'Scenario'] = '500: WORKERS COMPENSATION - No Pay'
    data.loc[pl_500_workers_comp_conditions, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[pl_500_workers_comp_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # PTO Logic: Extract information from NOTES field
    pto_supp_regex = r'wants to supplement with PTO'
    pto_bank_regex = r'wants to keep (\d+) weeks for RTW'

    # Identify rows with PTO supplementation
    data.loc[data['NOTES'].str.contains(pto_supp_regex, na=False, case=False), 'EE_SUPP_PTO'] = 'Y'

    # Extract PTO weeks from NOTES and create EE_PTO_RTW column
    data['EE_PTO_RTW'] = 2  # Default to 2 weeks
    for index, row in data.iterrows():
        match = re.search(pto_bank_regex, str(row['NOTES']), re.IGNORECASE)
        if match:
            data.at[index, 'EE_PTO_RTW'] = int(match.group(1))

    # Calculate PTO bank hours
    data['EE_PTO_BANK'] = data['EE_PTO_RTW'] * data['SCHED_HRS']

    # Standard calculations
    data['WEEKLY_WAGE'] = data['PAY_RATE'] * data['SCHED_HRS']
    data['MIN_WAGE_40'] = data['MIN_WAGE'] * 40
    data['95_CT_MIN_40'] = data['MIN_WAGE_40'] * 0.95
    data['CTPL_CALC_STAR'] = (data['WEEKLY_WAGE'] - data['MIN_WAGE_40']) * 0.6
    data['CTPL_CALC'] = data['95_CT_MIN_40'] + data['CTPL_CALC_STAR']

    # CTPL Payment calculations
    data['CTPL_PAYMENT_EST'] = data.apply(
        lambda x: min(x['CTPL_CALC'], x['MAX_CTPL_PAY']), axis=1
    )

    data['CTPL_PAYMENT'] = data.apply(
        lambda x: x['MAX_CTPL_PAY'] if pd.isna(x['CTPL_APPROVED_AMOUNT'])
        else x['CTPL_APPROVED_AMOUNT'], axis=1
    )

    #PTO calculations

    data['PTO_SUPP_DOLLARS'] = data['WEEKLY_WAGE'] - data['CTPL_PAYMENT'] - data['STD_OR_NOT']
    data['PTO_SUPP_HRS'] = data['PTO_SUPP_DOLLARS'] / data['PAY_RATE']

    # PTO Reserve calculations
    data['PTO_RESERVE'] = data.apply(
        lambda x: x['SCHED_HRS'] * 2 if x['EE_SUPP_PTO'] == 'N'
        else x['SCHED_HRS'] * x['EE_PTO_RTW'], axis=1
    )

    data['PTO_USABLE'] = data.apply(
        lambda x: max(x['PTO_AVAIL'] - x['PTO_RESERVE'], 0), axis=1
    )

    # Round calculated columns to 2 decimal places
    for col in calculated_columns:
        data[col] = data[col].round(2)

    # ---- Start MED/SURG Logic ----

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - STD, No CT PL, No PTO Supplement
    pl_500_medicalsurgical_std_no_ctpl__no_pto_supp_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
        (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
        ((data['CTPL_FORM'].isnull()) | (data['START_DATE'] > data['CTPL_END'])) &
        (data['EE_SUPP_PTO'] == 'N') &
        unmatched_rows
    )
    data.loc[pl_500_medicalsurgical_std_no_ctpl__no_pto_supp_conditions, 'Scenario'] = '500: MEDICAL/SURGICAL: STD, No CT PL, No PTO Supplement'
    data.loc[pl_500_medicalsurgical_std_no_ctpl__no_pto_supp_conditions, 'c_STD_HOURS'] = data['SCHED_HRS'] * 0.6
    data.loc[pl_500_medicalsurgical_std_no_ctpl__no_pto_supp_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - STD, CT PL, No PTO Supplement
    pl_500_medicalsurgical_std_ctpl_no_pto_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
      (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
      (data['CTPL_FORM'] == 'Y') &
      ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
      ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
      (data['EE_SUPP_PTO'] == 'N') &
    unmatched_rows
    )

    std_qualifying_rows = (
      pl_500_medicalsurgical_std_ctpl_no_pto_conditions &
      ((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )
    data.loc[std_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: STD, CT PL, No PTO Supplement'
    data.loc[std_qualifying_rows, 'c_STD_HOURS'] = data['STD_OR_NOT'] / data['PAY_RATE']
    data.loc[std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    non_std_qualifying_rows = (
      pl_500_medicalsurgical_std_ctpl_no_pto_conditions &
      ~((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )
    data.loc[non_std_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: STD, CT PL, No PTO Supplement (LOA)'
    data.loc[non_std_qualifying_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[non_std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - STD, CT PL, With PTO Supplement
    pl_500_medicalsurgical_std_ctpl_with_pto_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
      (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
      (data['CTPL_FORM'] == 'Y') &
      ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
      ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
      (data['EE_SUPP_PTO'] == 'Y') &
      unmatched_rows
    )

    std_qualifying_rows = (
      pl_500_medicalsurgical_std_ctpl_with_pto_conditions &
      ((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
      )
    data.loc[std_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: STD, CT PL, With PTO Supplement'
    data.loc[std_qualifying_rows, 'c_STD_HOURS'] = data['STD_OR_NOT'] / data['PAY_RATE']
    data.loc[std_qualifying_rows, 'c_PTO_HRS'] = data['PTO_USE_HRS']
    data.loc[std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    non_std_qualifying_rows = (
      pl_500_medicalsurgical_std_ctpl_with_pto_conditions &
      ~((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )
    data.loc[non_std_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: STD, CT PL, With PTO Supplement (LOA)'
    data.loc[non_std_qualifying_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[non_std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - No STD, No CT PL, No PTO Supplement
    pl_500_medicalsurgical_no_std_no_ctpl_no_pto_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
        ((data['STD_APPROVED_THROUGH'].isnull() | (data['START_DATE'] > data['STD_APPROVED_THROUGH']))) &
        ((data['CTPL_FORM'].isnull() | (data['START_DATE'] > data['CTPL_END']))) &
        (data['EE_SUPP_PTO'] == 'N') &
        unmatched_rows
    )
    data.loc[pl_500_medicalsurgical_no_std_no_ctpl_no_pto_conditions, 'Scenario'] = '500: MEDICAL/SURGICAL: No STD, No CT PL, No PTO Supplement'
    data.loc[pl_500_medicalsurgical_no_std_no_ctpl_no_pto_conditions, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[pl_500_medicalsurgical_no_std_no_ctpl_no_pto_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - No STD, No CT PL, With PTO Supplement
    pl_500_medical_surgical_no_std_no_ctpl_with_pto_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
      (data['STD_APPROVED_THROUGH'].isnull()) &
      (data['CTPL_FORM'].isnull()) &
      (data['EE_SUPP_PTO'] == 'Y') &
      unmatched_rows
    )

    pto_qualifying_rows = (
      pl_500_medical_surgical_no_std_no_ctpl_with_pto_conditions &
      (data['PTO_USABLE'] > 0)
    )

    data.loc[pto_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: No STD, No CT PL, With PTO Supplement'
    data.loc[pto_qualifying_rows, 'c_PTO_HRS'] = data['SCHED_HRS']
    data.loc[pto_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    non_pto_qualifying_rows = (
      pl_500_medical_surgical_no_std_no_ctpl_with_pto_conditions &
      ~(data['PTO_USABLE'] > 0)
    )

    data.loc[non_pto_qualifying_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: No STD, No CT PL, With PTO Supplement (LOA)'
    data.loc[non_pto_qualifying_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[non_pto_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - MEDICAL/SURGICAL - No STD, CT PL, With PTO Supplement
    pl_500_medicalsurgical_no_std_ctpl_with_pto_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'MEDICAL/SURGICAL') &
      ((data['STD_APPROVED_THROUGH'].isnull() | (data['START_DATE'] > data['STD_APPROVED_THROUGH']))) &
      (data['CTPL_FORM'] == 'Y') &
      ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
      ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
      (data['EE_SUPP_PTO'] == 'Y') &
      unmatched_rows
    )

    pto_rows = (
      pl_500_medicalsurgical_no_std_ctpl_with_pto_conditions &
      (data['PTO_USE_HRS'] > 0)
      )
    data.loc[pto_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: No STD, CT PL, With PTO Supplement'
    data.loc[pto_rows, 'c_PTO_HRS'] = data['PTO_USE_HRS']
    data.loc[pto_rows, 'c_CHECK_KRONOS'] = 'Y'

    no_pto_rows = (
      pl_500_medicalsurgical_no_std_ctpl_with_pto_conditions &
      ~(data['PTO_USE_HRS'] > 0)
    )
    data.loc[no_pto_rows, 'Scenario'] = '500: MEDICAL/SURGICAL: No STD, CT PL, With PTO Supplement (LOA)'
    data.loc[no_pto_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[no_pto_rows, 'c_CHECK_KRONOS'] = 'Y'


    # ---- START OF PREGNANCY LOGIC ----

    # Logic: PROCESS_LEVEL 500 - PREGNANCY - STD, CT PL, With PTO Supplement
    pl_500_pregnancy_std_ctpl_with_pto_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'PREGNANCY') &
        (data['START_DATE'] <= data['STD_APPROVED_THROUGH']) &
        (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
        (data['CTPL_FORM'] == 'Y') &
        ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
        ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
        (data['EE_SUPP_PTO'] == 'Y') &
        unmatched_rows
    )

    std_qualifying_rows = (
        pl_500_pregnancy_std_ctpl_with_pto_conditions &
        ((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )

    data.loc[std_qualifying_rows, 'Scenario'] = '500: PREGNANCY: STD, CT PL, With PTO Supplement'
    data.loc[std_qualifying_rows, 'c_STD_HOURS'] = data['STD_OR_NOT'] / data['PAY_RATE']
    data.loc[std_qualifying_rows, 'c_PTO_HRS'] = data['PTO_USE_HRS']
    data.loc[std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    non_std_qualifying_rows = (
        pl_500_pregnancy_std_ctpl_with_pto_conditions &
        ~((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )
    data.loc[non_std_qualifying_rows, 'Scenario'] = '500: PREGNANCY: STD, CT PL, With PTO Supplement (LOA)'
    data.loc[non_std_qualifying_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[non_std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - PREGNANCY - STD, CT PL, No PTO Supplement
    pl_500_pregnancy_std_ctpl_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'PREGNANCY') &
      (data['START_DATE'] <= data['STD_APPROVED_THROUGH']) &
      (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
      (data['CTPL_FORM'] == 'Y') &
      ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
      ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
      (data['EE_SUPP_PTO'] == 'N') &
      unmatched_rows
    )

    std_qualifying_rows = (
      pl_500_pregnancy_std_ctpl_conditions &
      ((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )

    data.loc[std_qualifying_rows, 'Scenario'] = '500: PREGNANCY - STD, CT PL, No PTO Supplement'
    data.loc[std_qualifying_rows, 'c_STD_HOURS'] = data['STD_OR_NOT'] / data['PAY_RATE']
    data.loc[std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    non_std_qualifying_rows = (
      pl_500_pregnancy_std_ctpl_conditions &
      ~((data['STD_OR_NOT'] / data['PAY_RATE']) > 0)
    )

    data.loc[non_std_qualifying_rows, 'Scenario'] = '500: PREGNANCY - STD, CT PL, No PTO Supplement (LOA)'
    data.loc[non_std_qualifying_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[non_std_qualifying_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - PREGNANCY - STD, No CT PL, No PTO Supplement
    pl_500_pregnancy_std_no_ctpl_no_pto_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'PREGNANCY') &
        (data['END_DATE'] <= data['STD_APPROVED_THROUGH']) &
        ((data['CTPL_FORM'].isnull() | (data['START_DATE'] > data['CTPL_END']))) &
        (data['EE_SUPP_PTO'] == 'N') &
        unmatched_rows
    )
    data.loc[pl_500_pregnancy_std_no_ctpl_no_pto_conditions, 'Scenario'] = '500: PREGNANCY: STD, No CT PL, No PTO Supplement'
    data.loc[pl_500_pregnancy_std_no_ctpl_no_pto_conditions, 'c_STD_HOURS'] = data['SCHED_HRS'] * 0.6
    data.loc[pl_500_pregnancy_std_no_ctpl_no_pto_conditions, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - PREGNANCY - No STD, CT PL (All PTO Scenarios)
    pl_500_pregnancy_no_std_ctpl_conditions = (
        (data['PROCESS_LEVEL'] == 500) &
        (data['REASON_CODE'] == 'PREGNANCY') &
        ((data['STD_APPROVED_THROUGH'].isnull()) | (data['START_DATE'] > data['STD_APPROVED_THROUGH'])) &
        (data['CTPL_FORM'] == 'Y') &
        ((data['START_DATE'] >= data['CTPL_START']) | data['CTPL_START'].isnull()) &
        ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
        unmatched_rows
    )

    pto_rows = pl_500_pregnancy_no_std_ctpl_conditions & (data['PTO_USE_HRS'] > 0)
    data.loc[pto_rows, 'Scenario'] = '500: PREGNANCY: No STD, CT PL, With PTO'
    data.loc[pto_rows, 'c_PTO_HRS'] = data['PTO_USE_HRS']
    data.loc[pto_rows, 'c_CHECK_KRONOS'] = 'Y'

    no_pto_rows = pl_500_pregnancy_no_std_ctpl_conditions & (data['PTO_USE_HRS'] <= 0)
    data.loc[no_pto_rows, 'Scenario'] = '500: PREGNANCY: No STD, CT PL, No PTO'
    data.loc[no_pto_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[no_pto_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - PREGNANCY - No STD, No CT PL (All PTO Scenarios)
    pl_500_pregnancy_no_std_no_ctpl_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'PREGNANCY') &
      ((data['STD_APPROVED_THROUGH'].isnull()) | (data['START_DATE'] > data['STD_APPROVED_THROUGH'])) &
      ((data['CTPL_FORM'].isnull()) | (data['START_DATE'] > data[('CTPL_END')])) &
      unmatched_rows
    )

    pto_usable_rows = pl_500_pregnancy_no_std_no_ctpl_conditions & (data['PTO_USABLE'] > 0)
    data.loc[pto_usable_rows, 'Scenario'] = '500: PREGNANCY: No STD, No CT PL, With PTO'
    data.loc[pto_usable_rows, 'c_PTO_HRS'] = data['SCHED_HRS']
    data.loc[pto_usable_rows, 'c_CHECK_KRONOS'] = 'Y'

    no_pto_usable_rows = pl_500_pregnancy_no_std_no_ctpl_conditions & ~(data['PTO_USABLE'] > 0)
    data.loc[no_pto_usable_rows, 'Scenario'] = '500: PREGNANCY: No STD, No CT PL, No PTO'
    data.loc[no_pto_usable_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[no_pto_usable_rows, 'c_CHECK_KRONOS'] = 'Y'


    # ---- Start of BONDING Logic ----

    # Logic: PROCESS_LEVEL 500 - BONDING - CT PL (All PTO Scenarios)
    pl_500_bonding_ctpl_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'BONDING') &
      (data['STD_APPROVED_THROUGH'].isnull()) &
      (data['CTPL_FORM'] == 'Y') &
      ((data['END_DATE'] <= data['CTPL_END']) | data['CTPL_END'].isnull()) &
    unmatched_rows
    )

    pto_rows = pl_500_bonding_ctpl_conditions & (data['PTO_USE_HRS'] > 0)
    data.loc[pto_rows, 'Scenario'] = '500: BONDING: CT PL, With PTO'
    data.loc[pto_rows, 'c_PTO_HRS'] = data['PTO_USE_HRS']
    data.loc[pto_rows, 'c_CHECK_KRONOS'] = 'Y'

    no_pto_rows = pl_500_bonding_ctpl_conditions & ~(data['PTO_USE_HRS'] > 0)
    data.loc[no_pto_rows, 'Scenario'] = '500: BONDING: CT PL, No PTO'
    data.loc[no_pto_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[no_pto_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Logic: PROCESS_LEVEL 500 - BONDING - No CT PL (All PTO Scenarios)
    pl_500_bonding_no_ctpl_conditions = (
      (data['PROCESS_LEVEL'] == 500) &
      (data['REASON_CODE'] == 'BONDING') &
      (data['STD_APPROVED_THROUGH'].isnull()) &
      ((data['CTPL_FORM'].isnull() | (data['START_DATE'] > data['CTPL_END']))) &
    unmatched_rows
    )

    pto_usable_rows = pl_500_bonding_no_ctpl_conditions & (data['PTO_USABLE'] > 0)
    data.loc[pto_usable_rows, 'Scenario'] = '500: BONDING: No CT PL, With PTO'
    data.loc[pto_usable_rows, 'c_PTO_HRS'] = data['SCHED_HRS']
    data.loc[pto_usable_rows, 'c_CHECK_KRONOS'] = 'Y'

    no_pto_usable_rows = pl_500_bonding_no_ctpl_conditions & ~(data['PTO_USABLE'] > 0)
    data.loc[no_pto_usable_rows, 'Scenario'] = '500: BONDING: No CT PL, No PTO'
    data.loc[no_pto_usable_rows, 'c_LOA_NO_HRS_PAID'] = data['SCHED_HRS']
    data.loc[no_pto_usable_rows, 'c_CHECK_KRONOS'] = 'Y'

    # Catch-all for rows that do not match any conditions
    data.loc[data['Scenario'] == '', 'Scenario'] = 'Not Found'

    return data

def summarize_results(data):
    total_cases = len(data)
    covered_cases = len(data[data['Scenario'] != 'Not Found'])
    covered_percentage = (covered_cases / total_cases) * 100
    scenario_summary = data['Scenario'].value_counts().sort_values(ascending=False)

    print("\nSummary of Results:")
    print(f"Total Cases: {total_cases}")
    print(f"Covered Cases: {covered_cases} ({covered_percentage:.2f}%)")
    print("\nScenario Breakdown:")
    for scenario, count in scenario_summary.items():
        percentage = (count / total_cases) * 100
        print(f"{scenario}: {count} ({percentage:.2f}%)")

def export_data(data):
    user_input = input("Would you like to export the data to an Excel file? (Y/N): ").strip().upper()
    if user_input == 'Y':
        file_name = "processed_data.xlsx"
        data.to_excel(file_name, index=False)
        print(f"Data exported successfully to {file_name}.")

# Example usage
if __name__ == "__main__":
    data_frame = upload_and_read_file()
    data_frame = apply_logic(data_frame)
    print("\nUpdated DataFrame:")
    display(data_frame.head(100))
    summarize_results(data_frame)
    export_data(data_frame)